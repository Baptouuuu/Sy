# Storage

Handling data is a key point in every application, and Sy comes with a full component dedicated to this problem.

The philosophy of this component is inspired by other libraries from other languages (not to mention [doctrine](http://www.doctrine-project.org/)).

It's separated into 2 main layers, the database access layer (DBAL) and the object relationnal mapper (ORM). And of course, the DBAL can be used without the ORM.

The DBAL ships with 3 databse drivers: `IndexedDB`, `localStorage` and `HTTP`. As the IndexedDB is the more restrictive one, it has imposed a structure for the other 2 so each one can be switched easily (but you'll learn more about it quickly).

From top to bottom you'll find these notions:

* [Entity](#entity)
* [Manager](#manager)
* [Repository](#repository)
* [UnitOfWork](#unitofwork)
* [LifeCycleEvent](#lifecycleevent)
* [DBAL](#dbal)

## Entity

An entity is the representation of your data (yes you don't deal with raw javascript objects). You create it just like any other 'class':

```js
var MyEntity = function () {
  this.someProperty = null;
};
MyEntity.prototype = Object.create(Sy.Entity.prototype);

var foo = new MyEntity();
```
Done!

By inheriting `Sy.Entity` you have access to 2 generic methods called `get` and `set`, but of course you can define your own getters and setters.

**Note**: it's a good practice to not access your entity data directly through properties but use getters and setters instead, so you have better control on what's set and retrieved to/from your entities.

Each entity class is associated to an alias in the engine, you can learn more about it in the [book](book/storage.md). (The engine use the config parameter `app.meta.entities` generated by the framework).

For now it doesn't go much further than this.

## Manager

The manager is your interface where you'll say an entity must be created/updated or removed from the database. By default a manager will handle all entities of your application but you'll learn how to restrict this. A manager is also bound to only one database driver.

But first, let's look at how to define a manager:
```js
Sy.kernel.getConfig()
  .set('storage.dbal.connections.myconn', {
    driver: 'indexeddb',
    dbname: 'myapp or wathever you want',
    version: 1
  })
  .set('storage.orm', {
    defaultManager: 'myManager',
    managers: {
      myManager: {
        connection: 'myconn'
      }
    }
  });
```
So here you first define a connection to a database (in this case an indexeddb one), and then we define a manager and associate it to our database connection.

Now we can access our manager via the [service](service-container.md) `sy::core::storage` (or via its alias `storage`).

```js
var entityManager = container.get('sy::core::storage').getManager('myManager');
```
As we defined a default manager name in the config, we could omit the parameter for `getManager`.

Enough of declaring stuff, let's dive in manipulating our entities.

### Creation

```js
var entity = new MyEntity();
entityManager.persist(entity);
entityManager.flush();
```
At this point I'm sure you're ondering why the hell do we need to call 2 methods to actually save our entity. The answer is simple: for speed. Say you're creating multiple entities at once, instead of calling the database each time to save every entity, it keeps them in a 'cache' and then send the order to create them when you call `flush`. It's important in the case you manipulate the DOM when you create your entities, you surely don't want heavy code firing that could make you lose the 16ms timeframe and make your app appear slugish.

**Important**: so always remember to call flush only when you're done on your action, never in the middle of handling your view.

### Update

In order to update an entity you first need to retrieve from the database:
```js
entityManager.find('EntityAlias', 'entity UUID')
  .then(function (entity) {
    entity.set('updatedAt', new Date());
    return entity;
  })
  .then(function (entity) {
    entityManager.flush();
  });
```
The important thing here is that you don't need to call the persist method. When you retrieve an entity from the database, it's automatically 'managed', meaning the engine keep tracks of it and automatically observe if it changes.

In this case, the engine notices the property `updatedAt` is modified and flag the entity to be updated at the next `flush`.

**Note**: to check if a entity is modified the engine use the Polymer library [observe-js](https://github.com/Polymer/observe-js), in the background it uses `Object.observe` if it's available, otherwise it will do dirty checking when the `flush` method is called (hence the need to carefully choose when you call this method).

### Remove

```js
entityManager.remove(entity);
entityManager.flush();
```
Same principle as before, you tell the engine what to do and then flush it. In the case the entity is about to be created, calling `remove` will prevent the entity from being created, and nothing will be sent to the database. Otherwise it will prevent any planned updates for this entity and will plan it for remove, so you don't have an unnecessary update call on your database before the remove one.


## Repository

Each entity comes with a repository, it's your interface to retrieve the entities. A default one is used for each entity type (but you'll learn in the [book](book/storage.md) how to create a custom one), providing you a basic set of methods.

This how you access a repository:
```js
entityManager.getRepository('EntityAlias');
```
This is self explanatory I suppose.

### Retrieving an entity by its identifier

Each entity as a default property called `uuid`, it's used by the engine to referene each entity and is string formatted like this: `xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx` (this identifier is generated the first time you persist an entity).

Now to retrieve an entity by its uuid, you'll do:
```js
entityManager.getRepository('entity uuid')
  .then(function (entity) {
    //you can access your entity here
  });
```
As every call to the databaseis done asynchrosnously, the method return a `Promise` so you can easily chain what you'll do as soon the entity is retrieved.

### Retrieving all entities

Is usual to retrieve all entities when you load your app (ie: all the todos). You can achieve this easily like so:
```js
repository.findAll()
  .then(function (entities) {
    //entities is a basic javascript Array
  });
```
Told you, easy!

### Searching entities

Most of the time you'll search your entities based on the value of a property of your entities. This is achievable like this:
```js
repository
  .findBy(
    'propertyName',
    'the value it must match',
    'integer to tell how many entities you want (optional)'
  )
  .then(function (entities) {
    //simple javascript Array
  });
```
It has been decided to restrict the search functionnality to what the `IndexedDB` can do, so you don't have to learn complex search queries like in MongoDB or MySQL.

If you use `IndexedDB` as driver, you'll need to declare the properties that can be searched (in order to build indexes); other drivers don't need it. To declare them you need to add a constant in your entoty prototype like so:

```js
MyEntity.prototype = Object.create(Sy.Entity.prototype, {
  INDEXES: {
    value: ['searchableProperty', 'propertyN']
  }
});
```
If you add new indexes after the `IndexedDB` database has been created, you'll need to increase the version number associated to your connection.

**Important**: the version number in the case of indexedDB must be an integer, float are converted to the closest lower integer ([indexedDB restriction](https://developer.mozilla.org/fr/docs/IndexedDB/Using_IndexedDB#Creating_or_updating_the_version_of_the_database)).

To go back on the search, the search value specified imply that it will return entities matching exactly this value. But you can also search for a property value between bounds, to do this you specify an `Array` with two values as the search value. Examples:

* `.findBy('foo', [0, 42])`: equivalent to `0 < foo < 42`
* `.findBy('foo', [undefined, 42])`: equivalent to `foo < 42`
* `.findBy('foo', [42, undefined])`: equivalent to `foo > 42`

### Searching one entity

Same principle as searching many entities, but this time it will resolve only one entity instead of an array. Example:

```js
repository
  .findOneBy('propertyName', 'value')
  .then(function (entity) {
    //entity instance of MyEntity
  });
```

## UnitOfWork

The `UnitOfWork` (aka UOW) is what seats between the manager and the driver, this is where the heavy stuff happens. Basically, it handles checking if entities must be updated, wrap raw data coming from the database to the appropriate entity, and fire [mediator](Mediator.md) channels before and after creation/update/removal. Most of the time you won't need to bother about it, but sometimes you may want to tune a bit more of how it should manage your entities.

But first to access it, you do it via the manager:
```js
var uow = entityManager.getUnitOfWork();
```

If you want to know if an entity is 'managed', meaning you called `persist` or retrieved it from the database, by the UOW you can do:
```js
uow.isManaged(entity); //will return a boolean
```
You can also do this directly via the manager: `entityManager.contains(entity)`.

You can also check if an entity will be created/updated or removed the next you `flush` the manager via 3 methdods: `isScheduledForInsert`, `isScheduledForUpdate` and `isScheduledForRemove` (each one taking an entity as parameter).

In some cases you'll want the UOW to stop managing a specific entity, meaning no changes will be applied in the database. You can achieve this like so:
```js
uow.detach(entity);
```
Or via the manager:
```js
entityManager.detach(entity);
```
This will remove any planned modification, meaning it will not be created, nor updated nor removed.

You can also detach all instances of `MyEntity` at once by calling:
```js
uow.clear('EntityAlias');
```
Or via the manager:
```js
entityManager.clear('EntityAlias');
```
If you call `clear` without arguments, it will detach all entities currenttly managed by the UOW.

**Note**: a UOW is bound to only one manager, so if detach all entities on one it will not affect other managers or UOW.
**Note**: you can also call `clear` on a repository (no arguments needed), it will only detach entities for this specific alias.

### Data extraction

The job of the UOW is also to extract the data out of your entities, and the send this raw data to the database driver. To do this, it uses the [`PropertyAccessor`](../src/PropertyAccessor.js) with [reflection](https://github.com/Baptouuuu/Reflection.js) enabled.

It means it will check all the defined properties, and on each one it will check if there's a specific getter for the property, then check for a generic getter and if none found it will access the data directly.

For example, for the property `foo_bar` it will check in this order:

* `entity.getFooBar()`
* `entity.get('foo_bar')`
* `entity.foo_bar`

This way you have full control to what will be sent to the database.

## LifeCycleEvent

Before and after an entity is created/updated or removed this [event](../src/Storage/LifeCycleEvent.js) is fired. It contains the entity alias and the actual entity. The event is fired via the [mediator](Mediator.md), in the end you have access to these 6 channels:

* `storage.pre.create`: available via `LifeCycleEvent.PRE_CREATE`
* `storage.post.create`: available via `LifeCycleEvent.POST_CREATE`
* `storage.pre.update`: available via `LifeCycleEvent.PRE_UPDATE`
* `storage.post.update`: available via `LifeCycleEvent.POST_UPDATE`
* `storage.pre.remove`: available via `LifeCycleEvent.PRE_REMOVE`
* `storage.post.remove`: available via `LifeCycleEvent.POST_REMOVE`

The event also gives you access to a method called `abort`, if you call it it will prevent the action being done, meaning no insertion, update nor removal. But to work, your listener must be synchronous (by default it's async).

## DBAL

This is the lowest layer in the engine, the one handling the connection to the database. As said in the introduction, it's completely decoupled from the upper layers, hence you can create a driver instance yourself and whatever you want.

Once again, the philosophy to how to store data has been taken from the native `IndexedDB` one. So to store a type of data you create a `store`, when working with the full stack, each entity has it's own store. And then you query for objects only for one store at a time (meaning you can't do joins like in SQL).

Depending on the driver those stores are built differently, you can check each of [these](../src/Storage/Dbal) to see the differences.

But each share a common [interface](../src/Storage/Dbal/DriverInterface.js), if you want to implement your own you'll have to implement this one too.

So for each, you have access to these methods: `read`, `create`, `update`, `remove`, `find` and `findAll`.

**Important**: if you use the `IndexedDB` driver, the first time you access the storage mechanism the connection to the database is establish, however the indexedDB api does it asynchronously so the first operation you'll do on the database will fail. To overcome the problem, you have access to a method called `whenOpened` that return a `Promise`, it's resolved once the onnection is established (so you should have a code looking like this: `driver.whenOpened().then(function () {/*here your code to query the db*/})`).

### Configuration

Here is a list of all the options available to declare drivers in the global config:
```js
config.set('storage.dbal', {
  defaultConnection: 'myConn',
  connections: {
    myConn: {
      driver: 'indexeddb',
      dbname: 'database name',
      version: 1,
      stores: [] //optional
    },
    myConn2: {
      driver: 'localstorage',
      dbname: 'database name',
      stores: [], //optional
      options: {
        temporary: false //optional, false => use localStorage, true => use sessionStorage
      }
    },
    myConn3: {
      driver: 'http',
      version: 1, //api version, optional
      stores: [], //optional
      options: {
        pattern: '/{version}/{bundle}/{name}/', //required, between brackets the available placeholders
        headers: [ //list of headers sent on each request
          ['HeaderName', 'header value']
        ]
      }
    }
  }
});
```
For each driver you can define the property `stores`, this used when working with the full stack. It restrict the creation of store for the specified aliases, all aliases are stored in the config under the key `app.meta.entities`. So for example, say you have an entity with the alias `FooBundle::MyEntity`, if you want only this kind of entity to be stored via your driver, you define for your connection: `stores: ['FooBundle::MyEntity']`.

